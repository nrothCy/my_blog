<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JreCekie</title>
  
  <subtitle>做一条有梦想的咸鱼！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nrothcy.github.io/"/>
  <updated>2020-05-18T16:26:51.441Z</updated>
  <id>https://nrothcy.github.io/</id>
  
  <author>
    <name>JreCekie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 内存模型概述</title>
    <link href="https://nrothcy.github.io/2020/05/16/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://nrothcy.github.io/2020/05/16/Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-05-16T03:29:48.000Z</published>
    <updated>2020-05-18T16:26:51.441Z</updated>
    
    <content type="html"><![CDATA[<p>​    Java程序在执行前首先会被编译成字节码文件，然后再由Java虚拟机执行这些字节码文件从而使得Java程序得以执行。事实上，在程序执行过程中，内存的使用和管理一直是值得关注的问题。Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些数据区域都有各自的用途，以及创建和销毁的时间，并且它们可以分为两种类型：线程共享的方法区和堆，线程私有的虚拟机栈、本地方法栈和程序计数器。在此基础上，我们探讨了在虚拟机中对象的创建和对象的访问定位等问题，并分析了Java虚拟机规范中异常产生的情况。             </p><p>​    本文内容是基于 JDK 1.6 的，不同版本虚拟机之间也许会有些许差异，但不影响我们对JVM 内存模型的整体把握和了解。 /gallery/01/images03.jpg</p><h2 id="一、-Java-虚拟机内存模型"><a href="#一、-Java-虚拟机内存模型" class="headerlink" title="一、 Java 虚拟机内存模型"></a>一、 Java 虚拟机内存模型</h2><p>​    Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些数据区域可以分为两个部分：一部分是线程共享的，一部分则是线程私有的。其中，线程共享的数据区包括方法区和堆，线程私有的数据区包括虚拟机栈、本地方法栈和程序计数器。如下图所示： </p><p><img src="/gallery/02/1408728-20190812093927815-1921644118.png" alt=""></p><h4 id="1、线程私有的数据区"><a href="#1、线程私有的数据区" class="headerlink" title="1、线程私有的数据区"></a>1、线程私有的数据区</h4><p>　　线程私有的数据区 包括 程序计数器、 虚拟机栈 和 本地方法栈 三个区域，它们的内涵分别如下：</p><p><strong>（1）、程序计数器</strong></p><p>　　我们知道，线程是CPU调度的基本单位。在多线程情况下，当线程数超过CPU数量或CPU内核数量时，线程之间就要根据 时间片轮询抢夺CPU时间资源。也就是说，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能够恢复到正确的执行位置，每条线程都需要一个独立的程序计数器去记录其正在执行的字节码指令地址。</p><p>　　因此，程序计数器是线程私有的一块较小的内存空间，其可以看做是当前线程所执行的字节码的行号指示器。如果线程正在执行的是一个 Java 方法，计数器记录的是正在执行的字节码指令的地址；如果正在执行的是 Native 方法，则计数器的值为空。</p><p>　　程序计数器是唯一一个没有规定任何 OutOfMemoryError 的区域。</p><p><strong>（2）、虚拟机栈</strong></p><p>　　虚拟机栈描述的是Java方法执行的内存模型，是线程私有的。每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，而且 每个方法从调用直至完成的过程，对应一个栈帧在虚拟机栈中入栈到出栈的过程。其中，局部变量表主要存放一些基本类型的变量（int, short, long, byte, float, double, boolean, char）和 对象句柄，它们可以是方法参数，也可以是方法的局部变量。</p><p>　　虚拟机栈有两种异常情况：StackOverflowError 和 OutOfMemoryError。我们知道，一个线程拥有一个自己的栈，这个栈的大小决定了方法调用的可达深度（递归多少层次，或嵌套调用多少层其他方法，-Xss 参数可以设置虚拟机栈大小），若线程请求的栈深度大于虚拟机允许的深度，则抛出 StackOverFlowError 异常。此外，栈的大小可以是固定的，也可以是动态扩展的，若虚拟机栈可以动态扩展（大多数虚拟机都可以），但扩展时无法申请到足够的内存(比如没有足够的内存为一个新创建的线程分配栈空间时)，则抛出 OutofMemoryError 异常。下图为栈帧结构图：</p><p><img src="/gallery/02/1408728-20190812094202607-1485648095.png" alt=""></p><p><strong>（3）、本地方法栈</strong></p><p>　　本地方法栈与Java虚拟机栈非常相似，也是线程私有的，区别是虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈为虚拟机执行 Native 方法服务。与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p><h4 id="2、线程共享的数据区"><a href="#2、线程共享的数据区" class="headerlink" title="2、线程共享的数据区"></a><strong>2、线程共享的数据区</strong></h4><p>　　线程共享的数据区 具体包括 Java堆 和 方法区 两个区域，它们的内涵分别如下</p><p><strong>（1）、Java 堆</strong></p><p>　　Java 堆的唯一目的就是存放对象实例，几乎所有的对象实例（和数组）都在这里分配内存。Java堆是线程共享的，类的对象从中分配空间，这些对象通过new、newarray、 anewarray 和 multianewarray 等指令建立，它们不需要程序代码来显式的释放。</p><p>　　由于Java堆唯一目的就是用来存放对象实例，因此其也是垃圾收集器管理的主要区域，故也称为称为 GC堆。从内存回收的角度看，由于现在的垃圾收集器基本都采用分代收集算法，所以为了方便垃圾回收Java堆还可以分为 新生代 和 老年代 。新生代用于存放刚创建的对象以及年轻的对象，如果对象一直没有被回收，生存得足够长，对象就会被移入老年代。新生代又可进一步细分为 eden、survivorSpace0 和 survivorSpace1。刚创建的对象都放入 eden，s0 (也有叫to)和 s1(from) 都至少经过一次GC并幸存。如果幸存对象经过一定时间仍存在，则进入老年代。下图给出了Java堆的结构图：</p><p><img src="/gallery/02/1408728-20190812094902297-2067448153.png" alt=""></p><p>​    注意，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。而且，Java堆在实现时，既可以是固定大小的，也可以是可拓展的，并且主流虚拟机都是按可扩展来实现的（通过-Xmx(最大堆容量) 和-Xms(最小堆容量)控制）。如果在堆中没有内存完成实例分配，并且堆也无法再拓展时，将会抛出OutOfMemoryError 异常。 </p><p><strong>TLAB (Thread Local Allocation Buffer，线程私有分配缓冲区)</strong></p><p>　　Sun Hotspot JVM 为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间 TLAB，其大小由JVM根据运行的情况计算而得。在TLAB上分配对象时不需要加锁(相对于CAS配上失败重试方式 )，因此JVM在给线程的对象分配内存时会尽量的在TLAB上分配，在这种情况下JVM中分配对象内存的性能和C基本是一样高效的，但如果对象过大的话则仍然是直接使用堆空间分配。</p><p>　　在下文中我们提到，虚拟机为新生对象分配内存时，需要考虑修改指针 (该指针用于划分内存使用空间和空闲空间) 时的线程安全问题，因为存在可能出现正在给对象A分配内存，指针还未修改，对象B又同时使用原来的指针分配内存的情况。TLAB 的存在就是为了解决这个问题：每个线程在Java堆中预先分配一小块内存 TLAB，哪个线程需要分配内存就在自己的TLAB上进行分配，若TLAB用完并分配新的TLAB时，再加同步锁定，这样就大大提升了对象内存分配的效率。</p><p><strong>（2）、方法区</strong></p><p>　　方法区与Java堆一样，也是线程共享的并且不需要连续的内存，其用于存储已被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区通常和永久区(Perm)关联在一起，但永久代与方法区不是一个概念，只是有的虚拟机用永久代来实现方法区，这样就可以用永久代GC来管理方法区，省去专门内存管理的工作。根据Java虚拟机规范的规定，当方法区无法满足内存分配的需求时，将抛出 OutOfMemoryError 异常。</p><p><strong>运行时常量池</strong></p><p>　　运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存放编译期生成的各种 字面量 和 符号引用。其中，字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等；而符号引用则属于编译原理方面的概念，包括以下三类常量：类和接口的全限定名、字段的名称和描述符 和 方法的名称和描述符。因为运行时常量池（Runtime Constant Pool）是方法区的一部分，那么当常量池无法再申请到内存时也会抛出 OutOfMemoryError 异常。</p><p>　　运行时常量池相对于Class文件常量池的一个重要特征是具备动态性。Java语言并不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中，比如字符串的手动入池方法intern()。</p><p><strong>Java堆 与 方法区的区别</strong></p><p>　　Java堆是 Java代码可及的内存，是留给开发人员使用的；而非堆（Non-Heap）是JVM留给自己用的，所以方法区、JVM内部处理或优化所需的内存 (如JIT编译后的代码缓存)、每个类结构 (如运行时常量池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。</p><p><strong>方法区的回收</strong></p><p>　　方法区的内存回收目标主要是针对 常量池的回收 和 对类型的卸载。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果在这时候发生内存回收，而且必要的话，这个“abc”常量就会被系统“请”出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p><p>　　判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p><blockquote><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</p><p>加载该类的ClassLoader已经被回收；</p><p>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p></blockquote><p>　　虚拟机可以对满足上述3个条件的无用类进行回收(卸载)，这里说的仅仅是“可以”，而不是和对象一样，不使用了就必然会回收。特别地，在大量使用反射、动态代理、CGLib等bytecode框架的场景，以及动态生成JSP和OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><h2 id="二-Java对象在虚拟机中的创建与访问定位"><a href="#二-Java对象在虚拟机中的创建与访问定位" class="headerlink" title="二. Java对象在虚拟机中的创建与访问定位"></a>二. Java对象在虚拟机中的创建与访问定位</h2><p>　　Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象被创建和使用。在此，我们以最流行的HotSpot虚拟机以及常用的内存区域Java堆为例来探讨在虚拟机中对象的创建和对象的访问等问题。</p><h4 id="1、对象在虚拟机中的创建过程"><a href="#1、对象在虚拟机中的创建过程" class="headerlink" title="1、对象在虚拟机中的创建过程"></a><strong>1、对象在虚拟机中的创建过程</strong></h4><p>　　(1). 检查虚拟机是否加载了所要new的类，若没加载，则首先执行相应的类加载过程。虚拟机遇到new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个引用代表的类是否已经被加载、解析和初始化过。</p><p>　   (2). 在类加载检查通过后，对象所需内存的大小在类加载完成后便可完全确定，虚拟机就会为新生对象分配内存。一般来说，根据Java堆中内存是否绝对规整，内存的分配有两种方式：</p><blockquote><p>​    指针碰撞：如果Java堆中内存绝对规整，所有用过的内存放在一边，空闲内存放在另一边，中间一个指针作为分界点的指示器，那分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相同的距离。</p><p>​    空闲列表：如果Java堆中内存并不规整，那么虚拟机就需要维护一个列表，记录哪些内存块是可用的，以便在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</p></blockquote><p> 除了如何划分可用空间之外，还需要考虑修改指针 (该指针用于划分内存使用空间和空闲空间)时的线程安全问题，因为存在可能出现正在给对象A分配内存，指针还未修改，对象B又同时使用原来的指针分配内存的情况。解决这个问题有两种方案：</p><p>​    对分配内存空间的动作进行同步处理：采用CAS+失败重试的方式保证更新操作的原子性；</p><p>​    把内存分配的动作按照线程划分的不同的空间中：每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB），哪个线程要分配内存，就在自己的TLAB上分配，如果TLAB用完并分配新的TLAB时，再加同步锁定。</p><p>​    （3）、 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。如果使用TLAB，也可以提前到TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><p>​    （4）、在上面的工作完成之后，从虚拟机的角度来看，一个新的对象已经产生了，但从Java程序的视角来看，对象的创建才刚刚开始，此时会执行(init)方法把对象按照程序员的意愿进行初始化，从而产生一个真正可用的对象。</p><h4 id="2、对象在虚拟机中的访问定位"><a href="#2、对象在虚拟机中的访问定位" class="headerlink" title="2、对象在虚拟机中的访问定位"></a><strong>2、对象在虚拟机中的访问定位</strong></h4><p>　　创建对象是为了使用对象，我们的Java程序通过栈上的reference数据来操作堆上的具体对象。在虚拟机规范中，reference类型中只规定了一个指向对象的引用，并没有定义这个引用使用什么方式去定位、访问堆中的对象的具体位置。目前的主流的访问方式有使用句柄访问和直接指针访问两种。</p><blockquote><p>句柄访问：Java堆中会划分出一块内存作为句柄池，栈中的reference指向对象的句柄地址，句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示。</p></blockquote><p><img src="/gallery/02/1408728-20190812100248107-1367834734.png" alt=""></p><blockquote><p>直接指针访问：reference中存储的就是对象地址。 </p></blockquote><p><img src="/gallery/02/1408728-20190812100404117-573817523.png" alt=""></p><p>​    总的来说，这两种对象访问定位方式各有千秋。使用句柄访问的最大好处就是reference中存储的是稳定的句柄地址，对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，reference本身不需要修改；而使用直接指针访问的最大好处就是速度快，节省了一次指针定位的时间开销。 </p><h2 id="三-内存异常产生情况分析"><a href="#三-内存异常产生情况分析" class="headerlink" title="三. 内存异常产生情况分析"></a>三. 内存异常产生情况分析</h2><h4 id="1、Java堆溢出-OOM"><a href="#1、Java堆溢出-OOM" class="headerlink" title="1、Java堆溢出 (OOM)"></a>1、Java堆溢出 (OOM)</h4><p>　　Java堆用于存储对象的实例，只要不断地创建对象，并且保证GC roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List list=<span class="keyword">new</span> ArrayList();   <span class="comment">// 持有“大对象”的引用，防止垃圾回收</span></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000000</span>];  <span class="comment">// 不断创建“大对象”</span></span><br><span class="line">            list.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/gallery/02/d058ccbf6c81800ac9f75f8dbe7bdaff838b47f3.jpg" alt=""></p><p>​    要解决这个异常，一般先通过内存映像分析工具对堆转储快照分析，确定内存的对象是否是必要的，即判断是 内存泄露 还是 内存溢出。如果是内存泄露，可以进一步通过工具查看泄露对象到GC Roots的引用链，比较准确地定位出泄露代码的位置。如果是内存溢出，可以调大虚拟机堆参数，或者从代码上检查是否存在某些对象生命周期过长的情况。</p><h4 id="2、虚拟机栈和本地方法栈溢出-SOF-OOM"><a href="#2、虚拟机栈和本地方法栈溢出-SOF-OOM" class="headerlink" title="2、虚拟机栈和本地方法栈溢出 (SOF/OOM)"></a>2、虚拟机栈和本地方法栈溢出 (SOF/OOM)</h4><p><strong>（1）SOF</strong></p><p>　　如果线程请求的栈深度大于虚拟机栈允许的最大深度，将抛出StackOverflowError异常。我们知道，每当Java程序启动一个新的线程时，Java虚拟机会为它分配一个栈，并且Java虚拟机栈以栈帧为单位保持线程运行状态。每当线程调用一个方法时，JVM就压入一个新的栈帧到这个线程的栈中，只要这个方法还没返回，这个栈帧就存在。 那么可以想象，如果方法的嵌套调用层次太多，比如递归调用，随着Java虚拟机栈中的栈帧的不断增多，最终很可能会导致这个线程的栈中的所有栈帧的大小的总和大于-Xss设置的值，从而产生StackOverflowError溢出异常。看下面的栗子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          method();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归调用导致 StackOverflowError</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/gallery/02/1408728-20190812100645633-1636653848.png" alt=""></p><p>​    上面的SOF异常就是由递归引起的，具体而言就是因为method()方法中没有递归终止条件，从而使得该方法不断递归调用、不断创建栈帧导致的。 </p><p><strong>（2） OOM</strong></p><p>　　如果虚拟机在拓展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。在虚拟机栈和本地方法栈发生OOM异常场景如下：当Java 程序启动一个新线程时，若没有足够的空间为该线程分配Java栈(一个线程Java栈的大小由-Xss设置决定)，JVM将抛出OutOfMemoryError异常。</p><h4 id="3、方法区和运行时常量池溢出-OOM"><a href="#3、方法区和运行时常量池溢出-OOM" class="headerlink" title="3、方法区和运行时常量池溢出 (OOM)"></a>3、方法区和运行时常量池溢出 (OOM)</h4><p>　　运行时常量池溢出的情况： String.intern()是一个native方法，在JDK1.6及之前的版本中，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象，否则将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。由于常量池分配在永久代中，如果不断地使用intern方法手动入池字符串，则会抛出OutOfMemoryError异常。但在JDK1.7及其以后的版本中，对intern（）方法的实现作了进一步改进，其不会再复制实例到常量池中，而仅仅是在常量池中记录首次出现的实例的引用。看下面的例子（在JDK1.7中运行）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"计算机"</span>).append(<span class="string">"软件"</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"java"</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    Output: </span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">     false</span></span><br><span class="line"><span class="comment">     */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure><p>​    为什么第一个返回true，而第二个返回false呢？因为在JDK1.7中，intern（）方法的实现不会再复制实例，只是在常量池中记录 首次 出现的实例的引用，因此str1.intern()和str1指向的是同一个字符串，所以返回true。同一个引用。对于“java”这个字符串，由于在执行StringBuilder.toString() 之前已经出现过，所以字符串常量池中在new StringBuilder(“java”).toString()之前已经有它的引用了，不符合首次出现的原则，因此返回fasle。有人可能心里可能就要嘀咕了，为啥第二个不符合首次出现的原则，而第一个就符合首次出现的原则呢？ 实际上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"java"</span>).toString();</span><br></pre></td></tr></table></figure><p> 等价于：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"java"</span>;</span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(s1);</span><br><span class="line">String str2 = sb.toString();</span><br><span class="line"></span><br><span class="line"><span class="comment">// StringBuilder 的 toString()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// Create a copy, don't share the array</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    由上面代码可知，字符串”java”早就出现了，因此不符合首次出现的原则，返回false。同理，“计算机软件”这个字符串在new StringBuilder(“计算机”).append(“软件”).toString()之前从未出现过，因此符合首次出现的原则，返回true。</p><blockquote><p><strong>方法区溢出的情况</strong>：一个类要被垃圾回收器回收掉，判断条件是比较苛刻的。 在经常动态产生大量Class的应用中，需要特别注意类的回收状况，比如动态语言、大量JSP或者动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    Java程序在执行前首先会被编译成字节码文件，然后再由Java虚拟机执行这些字节码文件从而使得Java程序得以执行。事实上，在程序执行过程中，内存的使用和管理一直是值得关注的问题。Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域
      
    
    </summary>
    
    
      <category term="Java" scheme="https://nrothcy.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://nrothcy.github.io/categories/Java/JVM/"/>
    
    
      <category term="Java" scheme="https://nrothcy.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>关于Nginx</title>
    <link href="https://nrothcy.github.io/2020/04/26/%E5%85%B3%E4%BA%8ENginx/"/>
    <id>https://nrothcy.github.io/2020/04/26/%E5%85%B3%E4%BA%8ENginx/</id>
    <published>2020-04-26T04:52:11.000Z</published>
    <updated>2020-05-03T13:35:16.850Z</updated>
    
    <content type="html"><![CDATA[<p>我们要知道 Nginx 是异步框架的网页服务器，是一个<strong>使用c语言开发的高性能的http服务器及反向代理服务器，</strong> 也可以用作反向代理、负载平衡器和 HTTP 缓存。 Nginx 是免费的开源软件，根据类 BSD 许可证的条款发布。 </p><h4 id="Nginx的产生"><a href="#Nginx的产生" class="headerlink" title="Nginx的产生"></a><strong>Nginx的产生</strong></h4><p>Nginx 同 Apache 一样都是一种 Web 服务器。基于 REST 架构风格，以统一资源描述符（Uniform Resources Identifier）URI 或者统一资源定位符（Uniform Resources Locator）URL 作为沟通依据，通过 HTTP 协议提供各种网络服务。 </p><p>然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个 Web 服务器有着各自鲜明的特点。 </p><p>Apache 的发展时期很长，而且是毫无争议的<a id="more"></a>世界第一大服务器。它有着很多优点：稳定、开源、跨平台等等。 它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在。所以它被设计为一个重量级的。 </p><p>它不支持高并发的服务器。在 Apache 上运行数以万计的并发访问，会导致服务器消耗大量内存。 </p><p>操作系统对其进行进程或线程间的切换也消耗了大量的 CPU 资源，导致 HTTP 请求的平均响应速度降低。</p><p>这些都决定了 Apache 不可能成为高性能 Web 服务器，轻量级高并发服务器 Nginx 就应运而生了。 </p><p>俄罗斯的工程师 Igor Sysoev，他在为 Rambler Media 工作期间，使用 C 语言开发了 Nginx。 Nginx 作为 Web 服务器一直为 Rambler Media 提供出色而又稳定的服务。然后呢，Igor Sysoev 将 Nginx 代码开源，并且赋予自由软件许可证。 </p><h4 id="关于Nginx为什么会流行"><a href="#关于Nginx为什么会流行" class="headerlink" title="关于Nginx为什么会流行"></a><strong>关于Nginx为什么会流行</strong></h4><p>Nginx 使用基于事件驱动架构，使得其可以支持数以百万级别的 TCP 连接。高度的模块化和自由软件许可证使得第三方模块层出不穷（这是个开源的时代啊）。Nginx 是一个跨平台服务器，可以运行在 Linux、Windows、FreeBSD、Solaris、AIX、Mac OS 等操作系统上。这些优秀的设计带来的极大的稳定性。</p><p>Nginx 能使用在的地方：</p><p>Nginx 是一款自由的、开源的、高性能的 HTTP 服务器和反向代理服务器；同时也是一个 IMAP、POP3、SMTP 代理服务器。</p><p>Nginx 可以作为一个 HTTP 服务器进行网站的发布处理，另外 Nginx 可以作为反向代理进行负载均衡的实现。</p><h4 id="代理概念"><a href="#代理概念" class="headerlink" title="代理概念"></a><strong>代理概念</strong></h4><p>说到代理，首先我们要明确一个概念，所谓代理就是一个代表、一个渠道；此时就涉及到两个角色，一个是被代理角色，一个是目标角色。</p><p>被代理角色通过这个代理访问目标角色完成一些任务的过程称为代理操作过程；如同生活中的专卖店，客人到 adidas 专卖店买了一双鞋，这个专卖店就是代理，被代理角色就是 adidas 厂家，目标角色就是用户。</p><h4 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a><strong>正向代理</strong></h4><p>正向代理也是大家最常接触到的代理模式，我们会从两个方面来说关于正向代理的处理模式，分别从软件方面和生活方面来解释一下什么叫正向代理。</p><p>在如今的网络环境下，我们如果由于技术需要要去访问国外的某些网站，此时你会发现位于国外的某网站我们通过浏览器是没有办法访问的。</p><p>此时大家可能都会用一个操作 FQ 进行访问，FQ 的方式主要是找到一个可以访问国外网站的代理服务器，我们将请求发送给代理服务器，代理服务器去访问国外的网站，然后将访问到的数据传递给我们！</p><p>上述这样的代理模式称为正向代理，正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p><p>客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的 IP 地址，还有代理程序的端口。 </p><p>总结来说：正向代理，”它代理的是客户端”，是一个位于客户端和原始服务器（Origin Server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器）。</p><p>然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p><p><strong>正向代理的用途：访问原来无法访问的资源，如 Google。可以做缓存，加速访问资源。对客户端访问授权，上网进行认证。代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息。</strong></p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a><strong>反向代理</strong></h4><p>明白了什么是正向代理，我们继续看关于反向代理的处理方式，举例如我国的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了。</p><p>此时就出现了一个大家耳熟能详的名词：分布式部署；也就是通过部署多台服务器来解决访问人数限制的问题。</p><p>某宝网站中大部分功能也是直接使用 Nginx 进行反向代理实现的，并且通过封装 Nginx 和其他的组件之后起了个高大上的名字：Tengine。</p><p>有兴趣的可以访问 Tengine 的官网查看具体的信息：<a href="http://tengine.taobao.org/">http://tengine.taobao.org/</a></p><p>反向代理是多个客户端给服务器发送的请求，Nginx 服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。</p><p>此时请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx 扮演的就是一个反向代理角色。</p><p>客户端是无感知代理的存在的，反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。因为客户端不需要任何配置就可以访问。</p><p>反向代理，”它代理的是服务端”，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息</p><p>反向代理的作用：</p><p>保证内网的安全，通常将反向代理作为公网访问地址，Web 服务器是内网。负载均衡，通过反向代理服务器来优化网站的负载。</p><h4 id="项目场景"><a href="#项目场景" class="headerlink" title="项目场景"></a><strong>项目场景</strong></h4><p>通常情况下，我们在实际项目操作时，正向代理和反向代理很有可能会存在同一个应用场景中，正向代理代理客户端的请求去访问目标服务器，目标服务器是一个反向单利服务器，反向代理了多台真实的业务处理服务器。 </p><p><img src="/gallery/02/09fa513d269759eeeb743023bdb5aa136c22df82.jpg" alt=""></p><p><img src="/gallery/02/d8f9d72a6059252d6eccb68824d5ea3e5ab5b933.jpg" alt=""></p><p>图解：</p><p>在正向代理中，Proxy 和 Client 同属于一个 LAN（图中方框内），隐藏了客户端信息。在反向代理中，Proxy 和 Server 同属于一个 LAN（图中方框内），隐藏了服务端信息。</p><p>实际上，Proxy 在两种代理中做的事情都是替服务器代为收发请求和响应，不过从结构上看正好左右互换了一下，所以把后出现的那种代理方式称为反向代理了。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h4><p>明确了所谓代理服务器的概念， 那么接下来，Nginx 扮演了反向代理服务器的角色，它是依据什么样的规则进行请求分发的呢？不用的项目应用场景，分发的规则是否可以控制呢？</p><p>这里提到的客户端发送的、Nginx 反向代理服务器接收到的请求数量，就是我们说的负载量。请求数量按照一定的规则进行分发，到不同的服务器处理的规则，就是一种均衡规则。</p><p>所以将服务器接收到的请求按照规则分发的过程，称为负载均衡。</p><p>负载均衡在实际项目操作过程中，有硬件负载均衡和软件负载均衡两种，硬件负载均衡也称为硬负载，如 F5 负载均衡，相对造价昂贵成本较高。</p><p>但是数据的稳定性安全性等等有非常好的保障，如中国移动中国联通这样的公司才会选择硬负载进行操作。</p><p>更多的公司考虑到成本原因，会选择使用软件负载均衡，软件负载均衡是利用现有的技术结合主机硬件实现的一种消息队列分发机制。</p><p><img src="/gallery/02/d058ccbf6c81800ac9f75f8dbe7bdaff838b47f3.jpg" alt=""></p><p>Nginx 支持的负载均衡调度算法方式如下：</p><p>①weight 轮询（默认）：接收到的请求按照顺序逐一分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx 会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。</p><p>这种方式下，可以给不同的后端服务器设置一个权重值（weight），用于调整不同的服务器上请求的分配率。</p><p>权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。</p><p>②ip_hash：每个请求按照发起客户端的 ip 的 hash 结果进行匹配，这样的算法下一个固定 ip 地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下 Session 共享的问题。</p><p>③fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配。</p><p>响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少，它是结合了前两者的优点的一种调度算法。</p><p>但是需要注意的是 Nginx 默认不支持 fair 算法，如果要使用这种调度算法，请安装 upstream_fair 模块。</p><p>④url_hash：按照访问的 URL 的 hash 结果分配请求，每个请求的 URL 会指向后端固定的某个服务器，可以在 Nginx 作为静态服务器的情况下提高缓存效率。</p><p>同样要注意 Nginx 默认不支持这种调度算法，要使用的话需要安装 Nginx 的 hash 软件包。</p><p>Web 服务器对比</p><p> 几种常用 Web 服务器对比如下图： </p><p><img src="/gallery/02/2fdda3cc7cd98d10dbbf91702e71510b7aec90d8.jpg" alt=""></p><p><dive style="color:#CCC">转载自：<a href="https://baijiahao.baidu.com/s?id=1652608869911988442&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1652608869911988442&amp;wfr=spider&amp;for=pc</a> </dive></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们要知道 Nginx 是异步框架的网页服务器，是一个&lt;strong&gt;使用c语言开发的高性能的http服务器及反向代理服务器，&lt;/strong&gt; 也可以用作反向代理、负载平衡器和 HTTP 缓存。 Nginx 是免费的开源软件，根据类 BSD 许可证的条款发布。 &lt;/p&gt;
&lt;h4 id=&quot;Nginx的产生&quot;&gt;&lt;a href=&quot;#Nginx的产生&quot; class=&quot;headerlink&quot; title=&quot;Nginx的产生&quot;&gt;&lt;/a&gt;&lt;strong&gt;Nginx的产生&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Nginx 同 Apache 一样都是一种 Web 服务器。基于 REST 架构风格，以统一资源描述符（Uniform Resources Identifier）URI 或者统一资源定位符（Uniform Resources Locator）URL 作为沟通依据，通过 HTTP 协议提供各种网络服务。 &lt;/p&gt;
&lt;p&gt;然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个 Web 服务器有着各自鲜明的特点。 &lt;/p&gt;
&lt;p&gt;Apache 的发展时期很长，而且是毫无争议的
    
    </summary>
    
    
      <category term="服务器" scheme="https://nrothcy.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="Nginx" scheme="https://nrothcy.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>测试</title>
    <link href="https://nrothcy.github.io/2020/03/24/%E6%B5%8B%E8%AF%95/"/>
    <id>https://nrothcy.github.io/2020/03/24/%E6%B5%8B%E8%AF%95/</id>
    <published>2020-03-23T20:15:35.000Z</published>
    <updated>2020-05-18T06:20:06.950Z</updated>
    
    <content type="html"><![CDATA[<p>评论系统邮箱使用QQ邮箱格式为“QQ号@qq.com”，否则头像将为空白</p><p>文章图片为随机</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;评论系统邮箱使用QQ邮箱格式为“QQ号@qq.com”，否则头像将为空白&lt;/p&gt;
&lt;p&gt;文章图片为随机&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://nrothcy.github.io/2020/03/20/hello-world/"/>
    <id>https://nrothcy.github.io/2020/03/20/hello-world/</id>
    <published>2020-03-19T20:23:24.470Z</published>
    <updated>2020-05-18T06:18:31.590Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
